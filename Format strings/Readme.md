# Overview 

format strings is prettu common out there and it has an impact in any application security, specially in leaking stuff and mitigation bypass.

here I will start documenting my learning process for this vulnerability starting from the very beginning level.

I decided to start looking at the following four levels of "phoenix [Exploit Education](https://exploit.education/).

# Concept

the format string vulnrability comes from that any function that takes a format string as a parameter blindly trusts that there is another parameters sublied to substitute the supplied format string with.

I will dig into explainning along side with challenges as we are starting from very beginning level.

# level0

```c
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

int main(int argc, char **argv) {
  struct {
    char dest[32];
    volatile int changeme;
  } locals;
  char buffer[16];

  printf("%s\n", BANNER);

  if (fgets(buffer, sizeof(buffer) - 1, stdin) == NULL) {
    errx(1, "Unable to get buffer");
  }
  buffer[15] = 0;

  locals.changeme = 0;

  sprintf(locals.dest, buffer);

  if (locals.changeme != 0) {
    puts("Well done, the 'changeme' variable has been changed!");
  } else {
    puts(
        "Uh oh, 'changeme' has not yet been changed. Would you like to try "
        "again?");
  }

  exit(0);
}
```
here we can notice that the buffer is safe from overflow as the "fgets" copies just data as the size buffer.

the problem here is that we are controlling the format string parameter for the "printf" function (see man page for sprintf(not printf!!!!)).

As "sprintf" copies based on format string that we control, we can overflow the "buffer" and change stack values below it.

As the buffer is 16 bytes we need "%x%x%x%x" to fill it, then entering the needed value to overwrite the "changeme" variable.

![Error](../Pics/formatstrings/pic9.png)

    level one has the same code just wants you to change it to specific value.

# level2

```c
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

int changeme;

void bounce(char *str) {
  printf(str);
}

int main(int argc, char **argv) {
  char buf[256];

  printf("%s\n", BANNER);

  if (argc > 1) {
    memset(buf, 0, sizeof(buf));
    strncpy(buf, argv[1], sizeof(buf));
    bounce(buf);
  }

  if (changeme != 0) {
    puts("Well done, the 'changeme' variable has been changed correctly!");
  } else {
    puts("Better luck next time!\n");
  }

  exit(0);
}
```

here we can see vulnrable "printf" function where we completly controll the format string parameter, we need here to find the  address of the "changeme" variable which is "0x0000000000600AF0"

here appears a problem which is when we look at the man page for "strncpy" we can see that it tops copying at the first null byte but here we have alot of them!!

but actually while debugging I noticed that this is not a big deal as the buffer is initialized with zeros means null bytes already there you don't need to write them.

So what we need now is

- write our format string with the adress of the "changeme" variable.

- locate where is our input in the stack.

- target the entered adress with "%n" to write there.






