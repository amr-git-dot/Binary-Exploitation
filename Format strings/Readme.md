# Overview 

format strings is pretty common out there and it has an impact on any application security, especially in leaking stuff and mitigation bypass.

here I will start documenting my learning process for this vulnerability starting from the very beginning level.

I decided to start looking at the following four levels of "phoenix [Exploit Education](https://exploit.education/).

# Concept

the format string vulnerability comes from that any function that takes a format string as a parameter blindly trusts that there is another parameter to substitute the supplied format string with.

I will dig into explaining alongside with challenges as we are starting from the very beginning level.

# level0

```c
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

int main(int argc, char **argv) {
  struct {
    char dest[32];
    volatile int changeme;
  } locals;
  char buffer[16];

  printf("%s\n", BANNER);

  if (fgets(buffer, sizeof(buffer) - 1, stdin) == NULL) {
    errx(1, "Unable to get buffer");
  }
  buffer[15] = 0;

  locals.changeme = 0;

  sprintf(locals.dest, buffer);

  if (locals.changeme != 0) {
    puts("Well done, the 'changeme' variable has been changed!");
  } else {
    puts(
        "Uh oh, 'changeme' has not yet been changed. Would you like to try "
        "again?");
  }

  exit(0);
}
```
here we can notice that the buffer is safe from overflow as the "fgets" copies just data as the size buffer.

the problem here is that we are controlling the format string parameter for the "printf" function (see man page for sprintf(not printf!!!!)).

As "sprintf" copies based on the format string that we control, we can overflow the "buffer" and change stack values below it.

As the buffer is 16 bytes we need "%x%x%x%x" to fill it, then enter the needed value to overwrite the "changeme" variable.

![Error](../Pics/formatstrings/pic9.png)

    level one has the same code just wants you to change it to a specific value.

# level2

```c
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

int changeme;

void bounce(char *str) {
  printf(str);
}

int main(int argc, char **argv) {
  char buf[256];

  printf("%s\n", BANNER);

  if (argc > 1) {
    memset(buf, 0, sizeof(buf));
    strncpy(buf, argv[1], sizeof(buf));
    bounce(buf);
  }

  if (changeme != 0) {
    puts("Well done, the 'changeme' variable has been changed correctly!");
  } else {
    puts("Better luck next time!\n");
  }

  exit(0);
}
```

here we can see the vulnerable "printf" function where we completely control the format string parameter, We need here to find the  address of the "changeme" variable which is "0x0000000000600AF0"

here appears a problem when we look at the man page for "strncpy" we can see that it tops copying at the first null byte but here we have a lot of them!!

but actually while debugging I noticed that this is not a big deal as the buffer is initialized with zeros means null bytes are already there you don't need to write them.

So what we need now is

- write our format string with the address of the "changeme" variable.

- locate where is our input in the stack.

- Target the entered address with "%n" to write there.


Here is a screen from my Ida debugging session where I stoped the execution exactly befor the "printf" function to see the layout of the stack and registers and the terminal window shows the output after the execution, where we can notice our "%p" started printing from rcx until reached our input "0x41414141"

![Error](../Pics/formatstrings/pic10.png)

now we need no change the "0x41414141" with "changeme" address and the last "%p" with "%n" and we are done.







