# Overview 

integer overflows are happening due to the difference in signed and unsigned integers which causes sanity checks bypass, under allocation, and over copy problems. 

if you have this code 

```c
int main(){
    char buf[64];
    int size = argv[1];
    if(size > 64){
        printf("possible overflow");
        exit(1);
    }
    memcpy(buf,argv[2],size);
    return 0;
}
```

Is this safe from stack overflow?!!!!

It may seems like there is a check but the check here is done with a signed integer, which means if we input "0xFFFFFFFF" as size that will pass sanity check as it represents -1 which is less than 64, but will copy this large size of data to overflow the buffer.
